<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>IndieLib - Crossplatform: IND_Math Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="indielib_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">IndieLib - Crossplatform
   </div>
   <div id="projectbrief">C++ 2.5d graphics library based in DirectX and OpenGL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_n_d___math-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IND_Math Class Reference<div class="ingroups"><a class="el" href="group___i_n_d___math.html">IND_Math</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates common math operations used through the library.  
 <a href="class_i_n_d___math.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_n_d___math_8h_source.html">IND_Math.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7bc00dc41c91ad925a4e54c7de1ec18d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a7bc00dc41c91ad925a4e54c7de1ec18d">init</a> ()</td></tr>
<tr class="memdesc:a7bc00dc41c91ad925a4e54c7de1ec18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object.  <a href="#a7bc00dc41c91ad925a4e54c7de1ec18d"></a><br/></td></tr>
<tr class="separator:a7bc00dc41c91ad925a4e54c7de1ec18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc7225acf77ab80e19aa138b832f83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49dc7225acf77ab80e19aa138b832f83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a49dc7225acf77ab80e19aa138b832f83">end</a> ()</td></tr>
<tr class="memdesc:a49dc7225acf77ab80e19aa138b832f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the manager and all the objects that it contains. <br/></td></tr>
<tr class="separator:a49dc7225acf77ab80e19aa138b832f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad753f19e63baee328c15f6ee680b658e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#ad753f19e63baee328c15f6ee680b658e">isOK</a> ()</td></tr>
<tr class="memdesc:ad753f19e63baee328c15f6ee680b658e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns state of initialization.  <a href="#ad753f19e63baee328c15f6ee680b658e"></a><br/></td></tr>
<tr class="separator:ad753f19e63baee328c15f6ee680b658e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9212be51a8aa5bf90ee185be7cd2514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#af9212be51a8aa5bf90ee185be7cd2514">randSeed</a> (long pNum)</td></tr>
<tr class="memdesc:af9212be51a8aa5bf90ee185be7cd2514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed for random numbers.  <a href="#af9212be51a8aa5bf90ee185be7cd2514"></a><br/></td></tr>
<tr class="separator:af9212be51a8aa5bf90ee185be7cd2514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Culling utilities</div></td></tr>
<tr class="memitem:a5621ea979e20dd56e80bb0cc8ac50206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a5621ea979e20dd56e80bb0cc8ac50206">calculateBoundingRectangle</a> (<a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *mP1, <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *mP2, <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *mP3, <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *mP4)</td></tr>
<tr class="memdesc:a5621ea979e20dd56e80bb0cc8ac50206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bounding rectangle surrounding a block.  <a href="#a5621ea979e20dd56e80bb0cc8ac50206"></a><br/></td></tr>
<tr class="separator:a5621ea979e20dd56e80bb0cc8ac50206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea8c0f031b18925db0cf79f9b382525"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a1ea8c0f031b18925db0cf79f9b382525">cullFrustumBox</a> (const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;pAABBMin, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;pAABBMax, <a class="el" href="struct_struct_frustrum.html">FRUSTRUMPLANES</a> &amp;pFrustrum)</td></tr>
<tr class="memdesc:a1ea8c0f031b18925db0cf79f9b382525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a box determined by 2 points, is inside the supplied frustrum.  <a href="#a1ea8c0f031b18925db0cf79f9b382525"></a><br/></td></tr>
<tr class="separator:a1ea8c0f031b18925db0cf79f9b382525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix utilities</div></td></tr>
<tr class="memitem:a2e11e492a67ade2849e8b2d401b50f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a2e11e492a67ade2849e8b2d401b50f3b">matrix4DMultiply</a> (const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;m1, const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;m2, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result) const </td></tr>
<tr class="memdesc:a2e11e492a67ade2849e8b2d401b50f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies 2 matrices.  <a href="#a2e11e492a67ade2849e8b2d401b50f3b"></a><br/></td></tr>
<tr class="separator:a2e11e492a67ade2849e8b2d401b50f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7a7b58c2055d75324105aeaa63e664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a6c7a7b58c2055d75324105aeaa63e664">matrix4DSetIdentity</a> (<a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;m) const </td></tr>
<tr class="memdesc:a6c7a7b58c2055d75324105aeaa63e664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes matrix as Identity.  <a href="#a6c7a7b58c2055d75324105aeaa63e664"></a><br/></td></tr>
<tr class="separator:a6c7a7b58c2055d75324105aeaa63e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cea8d4cb08de30970a755b697a5bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a10cea8d4cb08de30970a755b697a5bfd">matrix4DSetTranslation</a> (<a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;m, float transx, float transy, float transz) const </td></tr>
<tr class="memdesc:a10cea8d4cb08de30970a755b697a5bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes matrix as Translation Matrix.  <a href="#a10cea8d4cb08de30970a755b697a5bfd"></a><br/></td></tr>
<tr class="separator:a10cea8d4cb08de30970a755b697a5bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43fb29dd181152c90c4f86eddd8bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a7a43fb29dd181152c90c4f86eddd8bef">matrix4DSetRotationAroundAxis</a> (<a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;m, float angledegrees, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;axis) const </td></tr>
<tr class="memdesc:a7a43fb29dd181152c90c4f86eddd8bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes matrix as Rotation Matrix.  <a href="#a7a43fb29dd181152c90c4f86eddd8bef"></a><br/></td></tr>
<tr class="separator:a7a43fb29dd181152c90c4f86eddd8bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea73136568f1f4c7e8d8285715baf22c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#aea73136568f1f4c7e8d8285715baf22c">matrix4DSetScale</a> (<a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;m, float scalex, float scaley, float scalez) const </td></tr>
<tr class="memdesc:aea73136568f1f4c7e8d8285715baf22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes matrix as a Scale Matrix.  <a href="#aea73136568f1f4c7e8d8285715baf22c"></a><br/></td></tr>
<tr class="separator:aea73136568f1f4c7e8d8285715baf22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624506c653e024bcd4f02d8821860dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a624506c653e024bcd4f02d8821860dc4">matrix4DLookAtMatrixLH</a> (const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;r, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;u, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;l, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;p, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result) const </td></tr>
<tr class="memdesc:a624506c653e024bcd4f02d8821860dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a matrix to represent a rotation matrix from 3 axes: r (right), u(up), l(look) AND p (pos).  <a href="#a624506c653e024bcd4f02d8821860dc4"></a><br/></td></tr>
<tr class="separator:a624506c653e024bcd4f02d8821860dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab085177ca94cb68612a66be88e89291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#aab085177ca94cb68612a66be88e89291">matrix4DLookAtMatrixRH</a> (const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;r, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;u, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;l, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;p, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result) const </td></tr>
<tr class="memdesc:aab085177ca94cb68612a66be88e89291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a matrix to represent a rotation matrix from 3 axes: r (right), u(up), l(look) AND p (pos).  <a href="#aab085177ca94cb68612a66be88e89291"></a><br/></td></tr>
<tr class="separator:aab085177ca94cb68612a66be88e89291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a5ba0599b88cfea557449eae7d87f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#ace1a5ba0599b88cfea557449eae7d87f">matrix4DLookAtMatrixEyeLookUpRH</a> (const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;eye, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;lookAt, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;up, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result) const </td></tr>
<tr class="memdesc:ace1a5ba0599b88cfea557449eae7d87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a matrix to represent a rotation matrix from 3 axes: eye, lookat and up.  <a href="#ace1a5ba0599b88cfea557449eae7d87f"></a><br/></td></tr>
<tr class="separator:ace1a5ba0599b88cfea557449eae7d87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0db8ec24a562f4954fd6a7628880e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#ac0db8ec24a562f4954fd6a7628880e6d">matrix4DLookAtMatrixEyeLookUpLH</a> (const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;eye, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;lookAt, const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;up, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result) const </td></tr>
<tr class="memdesc:ac0db8ec24a562f4954fd6a7628880e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a matrix to represent a rotation matrix from 3 axes: eye, lookat and up.  <a href="#ac0db8ec24a562f4954fd6a7628880e6d"></a><br/></td></tr>
<tr class="separator:ac0db8ec24a562f4954fd6a7628880e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb71ecefedf0b95e662d6934c1e738f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#acb71ecefedf0b95e662d6934c1e738f9">matrix4DOrthographicProjectionRH</a> (float left, float right, float bottom, float top, float znear, float zfar, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result)</td></tr>
<tr class="memdesc:acb71ecefedf0b95e662d6934c1e738f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a matrix representing an orthonormal transformation.  <a href="#acb71ecefedf0b95e662d6934c1e738f9"></a><br/></td></tr>
<tr class="separator:acb71ecefedf0b95e662d6934c1e738f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde8f65bc0999384ecb2e2fd3821880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#aedde8f65bc0999384ecb2e2fd3821880">matrix4DOrthographicProjectionLH</a> (float left, float right, float bottom, float top, float znear, float zfar, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;result)</td></tr>
<tr class="memdesc:aedde8f65bc0999384ecb2e2fd3821880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a matrix representing an orthonormal transformation.  <a href="#aedde8f65bc0999384ecb2e2fd3821880"></a><br/></td></tr>
<tr class="separator:aedde8f65bc0999384ecb2e2fd3821880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix with vector utilities</div></td></tr>
<tr class="memitem:a34cd692ad278286d3b625e9c342737ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a34cd692ad278286d3b625e9c342737ae">transformVector3DbyMatrix4D</a> (<a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;vector, const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;mat) const </td></tr>
<tr class="memdesc:a34cd692ad278286d3b625e9c342737ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the column vector to the matrix (from the right side).  <a href="#a34cd692ad278286d3b625e9c342737ae"></a><br/></td></tr>
<tr class="separator:a34cd692ad278286d3b625e9c342737ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6e2b0ea4b8f30f1d27500eccb8f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a7cd6e2b0ea4b8f30f1d27500eccb8f48">transformVector2DbyMatrix4D</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;vector, const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;mat) const </td></tr>
<tr class="memdesc:a7cd6e2b0ea4b8f30f1d27500eccb8f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the column vector to the matrix (from the right side).  <a href="#a7cd6e2b0ea4b8f30f1d27500eccb8f48"></a><br/></td></tr>
<tr class="separator:a7cd6e2b0ea4b8f30f1d27500eccb8f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneus utilities</h2></td></tr>
<tr class="memitem:a5d5bf6804a3a0d994f37eff9929f46f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a5d5bf6804a3a0d994f37eff9929f46f9">isPowerOfTwo</a> (long pN)</td></tr>
<tr class="memdesc:a5d5bf6804a3a0d994f37eff9929f46f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares if a number is power of two.  <a href="#a5d5bf6804a3a0d994f37eff9929f46f9"></a><br/></td></tr>
<tr class="separator:a5d5bf6804a3a0d994f37eff9929f46f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115926ca2c0bb554e137f8968cc2ff14"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a115926ca2c0bb554e137f8968cc2ff14">randnum</a> (long pIni, long pEnd)</td></tr>
<tr class="memdesc:a115926ca2c0bb554e137f8968cc2ff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random number, given two boundary values.  <a href="#a115926ca2c0bb554e137f8968cc2ff14"></a><br/></td></tr>
<tr class="separator:a115926ca2c0bb554e137f8968cc2ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f63026f40eb141f7bfde9d61f02e0a"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:a80f63026f40eb141f7bfde9d61f02e0a"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a80f63026f40eb141f7bfde9d61f02e0a">radiansToAngle</a> (type rads, bool invert=false) const </td></tr>
<tr class="memdesc:a80f63026f40eb141f7bfde9d61f02e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs conversion from radians to degree units.  <a href="#a80f63026f40eb141f7bfde9d61f02e0a"></a><br/></td></tr>
<tr class="separator:a80f63026f40eb141f7bfde9d61f02e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c982bdb7a7caa8e55a1a9a6efa7f1e"><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr class="memitem:aa2c982bdb7a7caa8e55a1a9a6efa7f1e"><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#aa2c982bdb7a7caa8e55a1a9a6efa7f1e">angleToRadians</a> (type angle, bool invert=false) const </td></tr>
<tr class="memdesc:aa2c982bdb7a7caa8e55a1a9a6efa7f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs conversion from degrees to radian units.  <a href="#aa2c982bdb7a7caa8e55a1a9a6efa7f1e"></a><br/></td></tr>
<tr class="separator:aa2c982bdb7a7caa8e55a1a9a6efa7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6882d009d6381bb5a12cc73d3f21fd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a6882d009d6381bb5a12cc73d3f21fd04">minAndMax4</a> (int p1, int p2, int p3, int p4, int *pMax, int *pMin)</td></tr>
<tr class="memdesc:a6882d009d6381bb5a12cc73d3f21fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a minimum and maximum value of 4 values.  <a href="#a6882d009d6381bb5a12cc73d3f21fd04"></a><br/></td></tr>
<tr class="separator:a6882d009d6381bb5a12cc73d3f21fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92659d070b3f3715b3e748ada0444d25"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a92659d070b3f3715b3e748ada0444d25">itoa</a> (int val, char *buf)</td></tr>
<tr class="memdesc:a92659d070b3f3715b3e748ada0444d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-Platform version of itoa.  <a href="#a92659d070b3f3715b3e748ada0444d25"></a><br/></td></tr>
<tr class="separator:a92659d070b3f3715b3e748ada0444d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Collision calculation</h2></td></tr>
<tr class="memitem:a620461aba865eb31b9ac3fe889f4455d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a620461aba865eb31b9ac3fe889f4455d">isCircleToCircleCollision</a> (<a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *pB1, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> pMat1, float pScale1, <a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *pB2, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> pMat2, float pScale2)</td></tr>
<tr class="memdesc:a620461aba865eb31b9ac3fe889f4455d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check collision between two circles in different coordinate systems.  <a href="#a620461aba865eb31b9ac3fe889f4455d"></a><br/></td></tr>
<tr class="separator:a620461aba865eb31b9ac3fe889f4455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907f9537b1dd9ed0ef460645c2c18bd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a907f9537b1dd9ed0ef460645c2c18bd9">isTriangleToTriangleCollision</a> (<a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *pB1, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> pMat1, <a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *pB2, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> pMat2)</td></tr>
<tr class="memdesc:a907f9537b1dd9ed0ef460645c2c18bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check collision between two triangles in different coordinate systems.  <a href="#a907f9537b1dd9ed0ef460645c2c18bd9"></a><br/></td></tr>
<tr class="separator:a907f9537b1dd9ed0ef460645c2c18bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa2941e39f289ba1b0b3058390b7a50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a7aa2941e39f289ba1b0b3058390b7a50">isCircleToTriangleCollision</a> (<a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *pB1, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> pMat1, float pScale, <a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *pB2, <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> pMat2)</td></tr>
<tr class="memdesc:a7aa2941e39f289ba1b0b3058390b7a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check collision between a circle an a triangle in different coordinate systems.  <a href="#a7aa2941e39f289ba1b0b3058390b7a50"></a><br/></td></tr>
<tr class="separator:a7aa2941e39f289ba1b0b3058390b7a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a405927b9df4016d9cb6ccae310c5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#ab0a405927b9df4016d9cb6ccae310c5b">isTriangleToTriangleCollision</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;a1, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;b1, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;c1, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;a2, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;b2, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;c2)</td></tr>
<tr class="memdesc:ab0a405927b9df4016d9cb6ccae310c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check collision between two triangles in same coordinate system.  <a href="#ab0a405927b9df4016d9cb6ccae310c5b"></a><br/></td></tr>
<tr class="separator:ab0a405927b9df4016d9cb6ccae310c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf52d7f36de0e0c1912518017c3ba270"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#abf52d7f36de0e0c1912518017c3ba270">isCircleToCircleCollision</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pP1, int pRadius1, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pP2, int pRadius2)</td></tr>
<tr class="memdesc:abf52d7f36de0e0c1912518017c3ba270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check collision between two circles in same coordinate system.  <a href="#abf52d7f36de0e0c1912518017c3ba270"></a><br/></td></tr>
<tr class="separator:abf52d7f36de0e0c1912518017c3ba270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62826e1727477f5d72f165ef20c25f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#ae62826e1727477f5d72f165ef20c25f8">isCircleToTriangleCollision</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pPCenter, int pRadius, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pA2, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pB2, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pC2)</td></tr>
<tr class="memdesc:ae62826e1727477f5d72f165ef20c25f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check collision between a circle and a triangle in same coordinate system.  <a href="#ae62826e1727477f5d72f165ef20c25f8"></a><br/></td></tr>
<tr class="separator:ae62826e1727477f5d72f165ef20c25f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42920a70c9374fc7be3e37eff43cb70"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#af42920a70c9374fc7be3e37eff43cb70">pointToLineDistance</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pA, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pB, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;pC, bool pIsSegment)</td></tr>
<tr class="memdesc:af42920a70c9374fc7be3e37eff43cb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance from AB to C.  <a href="#af42920a70c9374fc7be3e37eff43cb70"></a><br/></td></tr>
<tr class="separator:af42920a70c9374fc7be3e37eff43cb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2ebdb295bf0c3e3ea1eb73600b46a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#a2b2ebdb295bf0c3e3ea1eb73600b46a1">isSegmentIntersection</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;a, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;b, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;c, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;d)</td></tr>
<tr class="memdesc:a2b2ebdb295bf0c3e3ea1eb73600b46a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is an intersection between two segments Segment 1 =&gt; (pAx, pAy) - (pBx, pBy) Segment 2 =&gt; (pCx, pCy) - (pDx, pDy)  <a href="#a2b2ebdb295bf0c3e3ea1eb73600b46a1"></a><br/></td></tr>
<tr class="separator:a2b2ebdb295bf0c3e3ea1eb73600b46a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae599b9e8288c3e47df01d0ef09268883"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_n_d___math.html#ae599b9e8288c3e47df01d0ef09268883">isPointInsideTriangle</a> (<a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;p, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;a, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;b, <a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;c)</td></tr>
<tr class="memdesc:ae599b9e8288c3e47df01d0ef09268883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if point p is inside the triangle with vertex a, b, c Technique from: <a href="http://www.blackpawn.com/texts/pointinpoly/default.html">http://www.blackpawn.com/texts/pointinpoly/default.html</a>.  <a href="#ae599b9e8288c3e47df01d0ef09268883"></a><br/></td></tr>
<tr class="separator:ae599b9e8288c3e47df01d0ef09268883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates common math operations used through the library. </p>
<p>This class is comprised by a set of static methods, and a set of object methds which need and <a class="el" href="class_i_n_d___math.html" title="Encapsulates common math operations used through the library.">IND_Math</a> instance created.</p>
<p><b>Note:</b> Math ttransform operations assume:</p>
<ul>
<li>right-handed coordinate system</li>
<li>matrix representation by column order (changed in matrix definition)</li>
<li>vectors as columns, and post-multiplying</li>
</ul>
<p>Great site with sense on this math stuff: <a href="http://www.mindcontrol.org/~hplus/graphics/matrix-layout.html">http://www.mindcontrol.org/~hplus/graphics/matrix-layout.html</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa2c982bdb7a7caa8e55a1a9a6efa7f1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type IND_Math::angleToRadians </td>
          <td>(</td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs conversion from degrees to radian units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>A value to convert to radian </td></tr>
    <tr><td class="paramname">invert</td><td>Will multiply the result radian values by -1 if this is true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value converted to radian </dd></dl>

</div>
</div>
<a class="anchor" id="a5621ea979e20dd56e80bb0cc8ac50206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::calculateBoundingRectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *&#160;</td>
          <td class="paramname"><em>mP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *&#160;</td>
          <td class="paramname"><em>mP2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *&#160;</td>
          <td class="paramname"><em>mP3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> *&#160;</td>
          <td class="paramname"><em>mP4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a bounding rectangle surrounding a block. </p>
<p>p1* &ndash; &ndash; <em>p2 | | | | | | p3</em> &ndash; &ndash; *p4</p>
<p>All points can be arbitrary, as the bounding rectangle gets max/min values to form a rectangle </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mP1</td><td>A point </td></tr>
    <tr><td class="paramname">mP2</td><td>A point </td></tr>
    <tr><td class="paramname">mP3</td><td>A point </td></tr>
    <tr><td class="paramname">mP4</td><td>A point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ea8c0f031b18925db0cf79f9b382525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int IND_Math::cullFrustumBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pAABBMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pAABBMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_struct_frustrum.html">FRUSTRUMPLANES</a> &amp;&#160;</td>
          <td class="paramname"><em>pFrustrum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a box determined by 2 points, is inside the supplied frustrum. </p>
<pre class="fragment">            Taking an AABB min and max in world space, work out its interaction with the view frustum
            0 is outside
            1 is partially in
            2 is completely within
            Note: the viewing frustum must be calculated first
</pre><p> Here we are testing boxes against the frustrum, using the technique called "Geometric Approach - Testing Boxes II" here: <a href="http://zach.in.tu-clausthal.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html">http://zach.in.tu-clausthal.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAABBMin</td><td>First vertex of the box </td></tr>
    <tr><td class="paramname">pAABBMax</td><td>Second vertex of the box </td></tr>
    <tr><td class="paramname">pFrustrum</td><td>Frustrum structure as per camera position, specified by 6 planes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bc00dc41c91ad925a4e54c7de1ec18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if initialized correctly, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a620461aba865eb31b9ac3fe889f4455d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isCircleToCircleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *&#160;</td>
          <td class="paramname"><em>pB1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a>&#160;</td>
          <td class="paramname"><em>pMat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScale1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *&#160;</td>
          <td class="paramname"><em>pB2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a>&#160;</td>
          <td class="paramname"><em>pMat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScale2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check collision between two circles in different coordinate systems. </p>
<p>Transforms the circle coordinates using supplied transform matrices, and computes collision</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pB1</td><td>Collision data for first circle-type collison </td></tr>
    <tr><td class="paramname">pMat1</td><td>Matrix used to transform from coordinates where circle is, to world coordinates </td></tr>
    <tr><td class="paramname">pScale1</td><td>Scale to apply to circle radius </td></tr>
    <tr><td class="paramname">pB2</td><td>Collision data for second circle-type collison </td></tr>
    <tr><td class="paramname">pMat2</td><td>Matrix used to transform from coordinates where circle is, to world coordinates </td></tr>
    <tr><td class="paramname">pScale2</td><td>Scale to apply to circle radius</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="abf52d7f36de0e0c1912518017c3ba270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isCircleToCircleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pRadius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pP2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pRadius2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check collision between two circles in same coordinate system. </p>
<p>Both circles must be in same coordinate system to work!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pP1</td><td>Center of first circle </td></tr>
    <tr><td class="paramname">pRadius1</td><td>Radius of first circle </td></tr>
    <tr><td class="paramname">pP2</td><td>Center of second circle </td></tr>
    <tr><td class="paramname">pRadius2</td><td>Radius of second circle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a7aa2941e39f289ba1b0b3058390b7a50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isCircleToTriangleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *&#160;</td>
          <td class="paramname"><em>pB1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a>&#160;</td>
          <td class="paramname"><em>pMat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *&#160;</td>
          <td class="paramname"><em>pB2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a>&#160;</td>
          <td class="paramname"><em>pMat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check collision between a circle an a triangle in different coordinate systems. </p>
<p>Transforms the triangle and circle coordinates using supplied transform matrices, and computes collision</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pB1</td><td>Collision data for circle-type collison </td></tr>
    <tr><td class="paramname">pMat1</td><td>Matrix used to transform from coordinates where circle is, to world coordinates </td></tr>
    <tr><td class="paramname">pScale</td><td>Scale to apply to circle radius </td></tr>
    <tr><td class="paramname">pB2</td><td>Collision data for triangle-type collision </td></tr>
    <tr><td class="paramname">pMat2</td><td>Matrix used to transform from coordinates where triangle is, to world coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ae62826e1727477f5d72f165ef20c25f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isCircleToTriangleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pPCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pA2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pB2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pC2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check collision between a circle and a triangle in same coordinate system. </p>
<p>Both elements must be in same coordinate system to work!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPCenter</td><td>Center of first circle </td></tr>
    <tr><td class="paramname">pRadius</td><td>Radius of first circle </td></tr>
    <tr><td class="paramname">pA2,pB2,pC2</td><td>Point of triangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad753f19e63baee328c15f6ee680b658e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isOK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns state of initialization. </p>
<dl class="section return"><dt>Returns</dt><dd>Will give true if object initialized correctly, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ae599b9e8288c3e47df01d0ef09268883"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IND_Math::isPointInsideTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if point p is inside the triangle with vertex a, b, c Technique from: <a href="http://www.blackpawn.com/texts/pointinpoly/default.html">http://www.blackpawn.com/texts/pointinpoly/default.html</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A point </td></tr>
    <tr><td class="paramname">a,b,c</td><td>Triangle point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if inside, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a5d5bf6804a3a0d994f37eff9929f46f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares if a number is power of two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pN</td><td>Number to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the number is power of two, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2b2ebdb295bf0c3e3ea1eb73600b46a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isSegmentIntersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if there is an intersection between two segments Segment 1 =&gt; (pAx, pAy) - (pBx, pBy) Segment 2 =&gt; (pCx, pCy) - (pDx, pDy) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>First segment </td></tr>
    <tr><td class="paramname">c,d</td><td>Second segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if segments intersect, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a907f9537b1dd9ed0ef460645c2c18bd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isTriangleToTriangleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *&#160;</td>
          <td class="paramname"><em>pB1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a>&#160;</td>
          <td class="paramname"><em>pMat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___bounding_collisions.html#ga911b99d64922dd25b82473c113209d07">BOUNDING_COLLISION</a> *&#160;</td>
          <td class="paramname"><em>pB2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a>&#160;</td>
          <td class="paramname"><em>pMat2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check collision between two triangles in different coordinate systems. </p>
<p>Transforms the triangle coordinates using supplied transform matrices, and computes collision</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pB1</td><td>Collision data for first triangle-type collision </td></tr>
    <tr><td class="paramname">pMat1</td><td>Matrix used to transform from coordinates where triangle is, to world coordinates </td></tr>
    <tr><td class="paramname">pB2</td><td>Collision data for second triangle-type collision </td></tr>
    <tr><td class="paramname">pMat2</td><td>Matrix used to transform from coordinates where triangle is, to world coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a405927b9df4016d9cb6ccae310c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IND_Math::isTriangleToTriangleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check collision between two triangles in same coordinate system. </p>
<p>Triangles are specified as (a1, b1, c1) and (a2, b2, c2). Triangles must be in same coordinate system for this method to work! </p>
<pre class="fragment">- First checks if each of the vertices of either triange is within inside the other triangle
- After that it checks for intersections between the triangle segments
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1,b1,c1</td><td>First triangle coordinates </td></tr>
    <tr><td class="paramname">a2,b2,c2</td><td>Second triangle coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collision, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a92659d070b3f3715b3e748ada0444d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int IND_Math::itoa </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross-Platform version of itoa. </p>
<p>support only 10 radix for easy use and better performance taken from <a href="http://code.google.com/p/my-itoa/">http://code.google.com/p/my-itoa/</a> (LGPL)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The int that needs to be converted </td></tr>
    <tr><td class="paramname">buf</td><td>The char buffer that is going to held the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the result String. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0db8ec24a562f4954fd6a7628880e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DLookAtMatrixEyeLookUpLH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>lookAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a matrix to represent a rotation matrix from 3 axes: eye, lookat and up. </p>
<p>It uses left handed coordinate system conventions It replaces gluLookAt directly (without multiplying the matrix to GL of course)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eye</td><td>Where camera is positioned </td></tr>
    <tr><td class="paramname">lookAt</td><td>Where camera looks to </td></tr>
    <tr><td class="paramname">up</td><td>Up vector from camera </td></tr>
    <tr><td class="paramname">result</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace1a5ba0599b88cfea557449eae7d87f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DLookAtMatrixEyeLookUpRH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>lookAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a matrix to represent a rotation matrix from 3 axes: eye, lookat and up. </p>
<p>It uses right handed coordinate system conventions It replaces gluLookAt directly (without multiplying the matrix to GL of course)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eye</td><td>Where camera is positioned </td></tr>
    <tr><td class="paramname">lookAt</td><td>Where camera looks to </td></tr>
    <tr><td class="paramname">up</td><td>Up vector from camera </td></tr>
    <tr><td class="paramname">result</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a624506c653e024bcd4f02d8821860dc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DLookAtMatrixLH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a matrix to represent a rotation matrix from 3 axes: r (right), u(up), l(look) AND p (pos). </p>
<p>It uses left handed coordinate system conventions. In some documentation you will see pos referred as eye (eye position) Form: AXES TRANSLATION [l1 l2 l3 0][ 1 -px] [u1 u2 u3 0][ 1 -py] [r1 r2 r3 0][ 1 -pz] [0 0 0 1][ 1 ]</p>
<p>Last column are dot products It is quite similar as the gluLookAt() function from OpenGL utility library, but using 3 axes vectors from camera</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Right camera vector </td></tr>
    <tr><td class="paramname">u</td><td>Up camera vector </td></tr>
    <tr><td class="paramname">l</td><td>Look camera vector </td></tr>
    <tr><td class="paramname">p</td><td>Where the camera is positioned </td></tr>
    <tr><td class="paramname">result</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab085177ca94cb68612a66be88e89291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DLookAtMatrixRH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a matrix to represent a rotation matrix from 3 axes: r (right), u(up), l(look) AND p (pos). </p>
<p>It uses right handed coordinate system conventions. In some documentation you will see pos referred as eye (eye position) Form: AXES TRANSLATION [l1 l2 l3 0][ 1 -px] [u1 u2 u3 0][ 1 -py] [r1 r2 r3 0][ 1 -pz] [0 0 0 1][ 1 ] </p>
<pre class="fragment">Last column are dot products
It is quite similar as the gluLookAt() function from OpenGL utility library, but using 3 axes vectors from camera
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Right camera vector </td></tr>
    <tr><td class="paramname">u</td><td>Up camera vector </td></tr>
    <tr><td class="paramname">l</td><td>Look camera vector </td></tr>
    <tr><td class="paramname">p</td><td>Where the camera is positioned </td></tr>
    <tr><td class="paramname">result</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e11e492a67ade2849e8b2d401b50f3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies 2 matrices. </p>
<pre class="fragment">In the form of R = M1*M2 (Post multiplication on the right) that means we take the rows from
the left, and the columns from the right as:
</pre><p>[ ][ ] [ M1 ][ M2 ] [ ][ ] = R [ ][ ]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>First matrix (left side) </td></tr>
    <tr><td class="paramname">m2</td><td>Second matrix (right side) </td></tr>
    <tr><td class="paramname">result</td><td>Result matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedde8f65bc0999384ecb2e2fd3821880"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DOrthographicProjectionLH </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>znear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zfar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a matrix representing an orthonormal transformation. </p>
<pre class="fragment">It uses left handed coordinate system conventions
It replaces glOrtho directly (without multiplying the matrix to GL of course)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left margin of view </td></tr>
    <tr><td class="paramname">right</td><td>Right margin of view </td></tr>
    <tr><td class="paramname">bottom</td><td>Bottom margin of view </td></tr>
    <tr><td class="paramname">top</td><td>Top margin of view </td></tr>
    <tr><td class="paramname">znear</td><td>Nearest z to show in view </td></tr>
    <tr><td class="paramname">zfar</td><td>Farthest z to show in view </td></tr>
    <tr><td class="paramname">result</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb71ecefedf0b95e662d6934c1e738f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DOrthographicProjectionRH </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>znear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zfar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a matrix representing an orthonormal transformation. </p>
<pre class="fragment">It uses right handed coordinate system conventions
It replaces glOrtho directly (without multiplying the matrix to GL of course)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left margin of view </td></tr>
    <tr><td class="paramname">right</td><td>Right margin of view </td></tr>
    <tr><td class="paramname">bottom</td><td>Bottom margin of view </td></tr>
    <tr><td class="paramname">top</td><td>Top margin of view </td></tr>
    <tr><td class="paramname">znear</td><td>Nearest z to show in view </td></tr>
    <tr><td class="paramname">zfar</td><td>Farthest z to show in view </td></tr>
    <tr><td class="paramname">result</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c7a7b58c2055d75324105aeaa63e664"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DSetIdentity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes matrix as Identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a43fb29dd181152c90c4f86eddd8bef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DSetRotationAroundAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angledegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes matrix as Rotation Matrix. </p>
<pre class="fragment">This one is tough (or representation of glRotatef(), some kind of quaternion represented as a matrix. 
</pre><p> Detailed formula can be found in the net.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix to initialize </td></tr>
    <tr><td class="paramname">angledegrees</td><td>Angle IN DEGREES </td></tr>
    <tr><td class="paramname">axis</td><td>Axis to rotate around to, typically, for 2d, is (0,0,1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea73136568f1f4c7e8d8285715baf22c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DSetScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalez</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes matrix as a Scale Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix to initialize </td></tr>
    <tr><td class="paramname">scalex,scaley,scalez</td><td>Scale values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10cea8d4cb08de30970a755b697a5bfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::matrix4DSetTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes matrix as Translation Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix to initialize </td></tr>
    <tr><td class="paramname">transx,transy,transz</td><td>Translation values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6882d009d6381bb5a12cc73d3f21fd04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::minAndMax4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pMin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a minimum and maximum value of 4 values. </p>
<p>Given 4 values, it calculates and returns the maximum and minimum values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p1</td><td>Value to compare </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p2</td><td>Value to compare </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p3</td><td>Value to compare </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p4</td><td>Value to compare </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pMax</td><td>Max value result </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pMin</td><td>Min value result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af42920a70c9374fc7be3e37eff43cb70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double IND_Math::pointToLineDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pIsSegment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the distance from AB to C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA,pB</td><td>Sement or line point </td></tr>
    <tr><td class="paramname">pC</td><td>Point to compute distance from </td></tr>
    <tr><td class="paramname">pIsSegment</td><td>If true, AB is a segment, not a line</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of distance </dd></dl>

</div>
</div>
<a class="anchor" id="a80f63026f40eb141f7bfde9d61f02e0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type IND_Math::radiansToAngle </td>
          <td>(</td>
          <td class="paramtype">type&#160;</td>
          <td class="paramname"><em>rads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs conversion from radians to degree units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rads</td><td>A value to convert to degrees </td></tr>
    <tr><td class="paramname">invert</td><td>Will multiply the result degrees values by -1 if this is true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value converted to degrees </dd></dl>

</div>
</div>
<a class="anchor" id="a115926ca2c0bb554e137f8968cc2ff14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long IND_Math::randnum </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pIni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random number, given two boundary values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIni</td><td>Lowest possible value to generate </td></tr>
    <tr><td class="paramname">pEnd</td><td>Higher possible value to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random number between the two boundaries </dd></dl>

</div>
</div>
<a class="anchor" id="af9212be51a8aa5bf90ee185be7cd2514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::randSeed </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed for random numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNum</td><td>a number to initiate random seed with. Should be different always, like a time() value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cd6e2b0ea4b8f30f1d27500eccb8f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::transformVector2DbyMatrix4D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector2.html">IND_Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the column vector to the matrix (from the right side). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector to multiply (right side), will be modified directly with transform. </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix, left side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34cd692ad278286d3b625e9c342737ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IND_Math::transformVector3DbyMatrix4D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_n_d___vector3.html">IND_Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___math__strucutures.html#gaf486c298edce0d5a57d53383b3b5627f">IND_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the column vector to the matrix (from the right side). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector to multiply (right side), will be modified directly with transform. </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix, left side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/mquinones/Desktop/SOFTWARE DEV/PROJECTS/indielib-gitrepo/IndieLib/common/include/<a class="el" href="_i_n_d___math_8h_source.html">IND_Math.h</a></li>
<li>/Users/mquinones/Desktop/SOFTWARE DEV/PROJECTS/indielib-gitrepo/IndieLib/common/src/IND_Math.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 6 2013 21:40:21 for IndieLib - Crossplatform by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
